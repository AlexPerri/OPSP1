#include "userprog/syscall.h"
#include <stdio.h>
#include <syscall-nr.h>
#include "threads/interrupt.h"
#include "threads/thread.h"
#include "threads/synch.h"

static void syscall_handler (struct intr_frame *);
struct lock sysLock;
struct theFile
{
    struct list_elem felem;
    struct file *address;
    int num;
};

void
syscall_init (void) 
{
  lock_init(&sysLock);
  intr_register_int (0x30, 3, INTR_ON, syscall_handler, "syscall");
}

static void
syscall_handler (struct intr_frame *f UNUSED) 
{
  switch(*(int*)f->esp)
  {
    case SYS_WRITE:
      int args[3];
      void *page_ptr;
      int *ptr;
      for (int i = 0; i < 3; i++)
      {
        ptr = (int *) f->esp + i + 1;
        args[i] = *ptr;
      }
      /* Ensures that converted address is valid. */
      phys_page_ptr = pagedir_get_page(thread_current()->pagedir, (const void *) args[1]);
      if (phys_page_ptr == NULL)
      {
        exit(-1);
      }
      args[1] = (int) phys_page_ptr;

      /* Return the result of the write() function in the eax register. */
      f->eax = write(args[0], (const void *) args[1], (unsigned) args[2]);
      break;
  }
  thread_exit ();
}

int write (int fd, const void *buffer, unsigned size)
{
  struct thread *cur = thread_current();
  if (fd == STDOUT_FILENO)
  { 
    //writes byte size
      putbuf(buffer, size);
      return size;
  }
  if (fd == 0 || list_empty(&cur->fileL))
  {
    return 0;
  }
  for (struct list_elem *scan = list_front(&cur->fileL);scan != NULL; scan = scan->next)
  {
      struct theFile *f = list_entry (scan, struct theFile, felem);
      if (f->num == fd)
      {
        int bytes = (int) file_write(f->address, buffer, size);
        return bytes;
      }
  }  

}

